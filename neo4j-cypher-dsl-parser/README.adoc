= TCK for Cypher-DSL Parser

Most of the examples / test cases here use the default renderer that always escapes all names.
This is unrelated to the actual parsing and can be turned of when rendering the Cypher-DSL-AST.

== Nodes

Nodes can be parsed and used in constructions of queries for example.
They are probably one of the most useful elements.

Parse them via:

[source,java,indent=0,tabsize=4]
----
import org.neo4j.cypherdsl.parser.CypherParser;

public class Demo {
	public static void main(String...a) {
		var node = CypherParser.parseNode("(m:Movie)");
	}
}
----

[[nodes-input]]
.Input
[source,cypher]
----
()
(:`A`)
(:A)
(:A:B)
(:A:`B`:C)
(m)
(m:Movie)
(m {a:'b'})
(m {a:'b', c: 'd'})
----

They will look like this when rendered with the default renderer:

[[nodes-output]]
.Output
[source,cypher]
----
()
(:`A`)
(:`A`)
(:`A`:`B`)
(:`A`:`B`:`C`)
(m)
(m:`Movie`)
(m {a: 'b'})
(m {a: 'b', c: 'd'})
----

== Clauses

Clauses can be parsed like this:

[source,java,indent=0,tabsize=4]
----
import java.util.List;

import org.neo4j.cypherdsl.core.Statement;
import org.neo4j.cypherdsl.core.renderer.Renderer;

public class Demo {
	public static void main(String... a) {
		var clause = CypherParser.parseClause("MATCH (tom:Person {name: \"Tom Hanks\"})-[:ACTED_IN]->(tomHanksMovies)");
		var cypher = Renderer.getDefaultRenderer().render(Statement.of(List.of(clause)));
		System.out.println(cypher);
	}
}
----

These are the supported clauses:

[[clauses-input]]
.Input
[source,cypher]
----
MATCH (tom {name: "Tom Hanks"})
MATCH (tom:Person {name: "Tom Hanks"})-[:ACTED_IN]->(tomHanksMovies)
MATCH (n:Movie), (m:Person)
DELETE n
DETACH DELETE n
RETURN n
RETURN n ORDER by n.name
RETURN n ORDER by n.name desc
RETURN n ORDER by n.name SKIP 5
RETURN n ORDER by n.name SKIP 5 LIMIT 10
RETURN n ORDER by n.name, n.firstName SKIP 5 LIMIT 10
RETURN n.name AS name, n.firstName as vorname ORDER by n.name, n.firstName SKIP 5 LIMIT 10
RETURN distinct n
RETURN collect(n)
CREATE (m:Movie)
CREATE (m:Movie {title: "A title"})
CREATE (a:Person) -[:ACTED_IN] -> (m:Movie {title: "A title"})
MERGE (m:Movie)
MERGE (m:Movie {title: "A title"})
MERGE (a:Person) -[:ACTED_IN] -> (m:Movie {title: "A title"})
WITH a
WITH a WHERE a.name = 'Michael'
WITH a ORDER by n.name, n.firstName desc SKIP 5 LIMIT 10 WHERE a.name = 'Michael'
----

[[clauses-output]]
.Rendered output
[source,cypher]
----
MATCH (tom {name: 'Tom Hanks'})
MATCH (tom:`Person` {name: 'Tom Hanks'})-[:`ACTED_IN`]->(tomHanksMovies)
MATCH (n:`Movie`), (m:`Person`)
DELETE n
DETACH DELETE n
RETURN n
RETURN n ORDER BY n.name ASC
RETURN n ORDER BY n.name DESC
RETURN n ORDER BY n.name ASC SKIP 5
RETURN n ORDER BY n.name ASC SKIP 5 LIMIT 10
RETURN n ORDER BY n.name ASC, n.firstName ASC SKIP 5 LIMIT 10
RETURN n.name AS name, n.firstName AS vorname ORDER BY n.name ASC, n.firstName ASC SKIP 5 LIMIT 10
RETURN DISTINCT n
RETURN collect(n)
CREATE (m:`Movie`)
CREATE (m:`Movie` {title: 'A title'})
CREATE (a:`Person`)-[:`ACTED_IN`]->(m:`Movie` {title: 'A title'})
MERGE (m:`Movie`)
MERGE (m:`Movie` {title: 'A title'})
MERGE (a:`Person`)-[:`ACTED_IN`]->(m:`Movie` {title: 'A title'})
WITH a
WITH a WHERE a.name = 'Michael'
WITH a ORDER BY n.name ASC, n.firstName DESC SKIP 5 LIMIT 10 WHERE a.name = 'Michael'
----

== Whole queries

Of course, you can parse a query into a Cypher-DSL statement.
Such a statement could be combined with another statement into `UNION` query or be used as a subquery.

[[statements-input]]
.Input
[source,cypher,separated=true]
----
MATCH (n)
RETURN n;
MATCH (movie:Movie)
RETURN movie.title;
MATCH (director {name: 'Oliver Stone'})--(movie)
RETURN movie.title;
MATCH (wallstreet {title: 'Wall Street'})<-[:ACTED_IN|:DIRECTED]-(person)
RETURN person.name;
MATCH
  (charlie:Person {name: 'Charlie Sheen'}),
  (rob:Person {name: 'Rob Reiner'})
CREATE (rob)-[:`TYPE INCLUDING A SPACE`]->(charlie);
MATCH (n {name: 'Andy'})
SET n.surname = 'Taylor'
RETURN n.name, n.surname;
MATCH (n {name: 'Andy'})
SET (CASE WHEN n.age = 36 THEN n END).worksIn = 'Malmo'
RETURN n.name, n.worksIn;
MATCH
  (at {name: 'Andy'}),
  (pn {name: 'Peter'})
SET at = pn
RETURN at.name, at.age, at.hungry, pn.name, pn.age;
MATCH (n)
RETURN
CASE
  WHEN n.eyes = 'blue' THEN 1
  WHEN n.age < 40      THEN 2
  ELSE 3
END AS result;
MATCH (actor:Person {name: 'Charlie Sheen'})-[:ACTED_IN]->(movie:Movie)
RETURN actor{.name, .realName, movies: collect(movie{.title, .year})};
MATCH (actor:Person)-[:ACTED_IN]->(movie:Movie)
WITH actor, count(movie) AS nbrOfMovies
RETURN actor{.name, nbrOfMovies};
MATCH (actor:Person {name: 'Charlie Sheen'})
RETURN actor{.*, .age};
MATCH (p {name: 'Peter'})
SET p = {name: 'Peter Smith', position: 'Entrepreneur'}
RETURN p.name, p.age, p.position;
MATCH (p {name: 'Peter'})
SET p += {age: 38, hungry: true, position: 'Entrepreneur'}
RETURN p.name, p.age, p.hungry, p.position;
MATCH (p {name: 'Peter'})
SET p += {}
RETURN p.name, p.age;
MATCH (n {name: 'Andy'})
SET n.position = 'Developer', n.surname = 'Taylor';
MATCH (n {name: 'Andy'})
SET n.surname = $surname
RETURN n.name, n.surname;
MATCH (n {name: 'Stefan'})
SET n:German
RETURN n.name, labels(n) AS labels;
MATCH (n {name: 'George'})
SET n:Swedish:Bossman
RETURN n.name, labels(n) AS labels;
MATCH (a {name: 'Andy'})
REMOVE a.age
RETURN a.name, a.age;
MATCH (n {name: 'Peter'})
REMOVE n:German
RETURN n.name, labels(n);
MATCH (n {name: 'Peter'})
REMOVE n:German:Swedish
RETURN n.name, labels(n);
MATCH (n:Actor)
RETURN n.name AS name
UNION ALL
MATCH (n:Movie)
RETURN n.title AS name;
MATCH (n:Actor)
RETURN n.name AS name
UNION
MATCH (n:Movie)
RETURN n.title AS name;
UNWIND [1, 2, 3, null] AS x
RETURN x, 'val' AS y;
WITH [1, 1, 2, 2] AS coll
UNWIND coll AS x
WITH DISTINCT x
RETURN collect(x) AS setOfVals;
WITH
  [1, 2] AS a,
  [3, 4] AS b
UNWIND (a + b) AS x
RETURN x;
WITH [[1, 2], [3, 4], 5] AS nested
UNWIND nested AS x
UNWIND x AS y
RETURN y;
UNWIND [] AS empty
RETURN empty, 'literal_that_is_not_returned';
MATCH p=(start)-[*]->(finish)
WHERE start.name = 'A' AND finish.name = 'D'
RETURN p;
MATCH (person:Person) WHERE person.firstname STARTS WITH 'And' RETURN person;
----

[[statements-output]]
.Output
[source,cypher]
----
MATCH (n) RETURN n
MATCH (movie:`Movie`) RETURN movie.title
MATCH (director {name: 'Oliver Stone'})--(movie) RETURN movie.title
MATCH (wallstreet {title: 'Wall Street'})<-[:`ACTED_IN`|`DIRECTED`]-(person) RETURN person.name
MATCH (charlie:`Person` {name: 'Charlie Sheen'}), (rob:`Person` {name: 'Rob Reiner'}) CREATE (rob)-[:`TYPE INCLUDING A SPACE`]->(charlie)
MATCH (n {name: 'Andy'}) SET n.surname = 'Taylor' RETURN n.name, n.surname
MATCH (n {name: 'Andy'}) SET (CASE WHEN n.age = 36 THEN n END).worksIn = 'Malmo' RETURN n.name, n.worksIn
MATCH (at {name: 'Andy'}), (pn {name: 'Peter'}) SET at = pn RETURN at.name, at.age, at.hungry, pn.name, pn.age
MATCH (n) RETURN CASE WHEN n.eyes = 'blue' THEN 1 WHEN n.age < 40 THEN 2 ELSE 3 END AS result
MATCH (actor:`Person` {name: 'Charlie Sheen'})-[:`ACTED_IN`]->(movie:`Movie`) RETURN actor{.name, .realName, movies: collect(movie{.title, .year})}
MATCH (actor:`Person`)-[:`ACTED_IN`]->(movie:`Movie`) WITH actor, count(movie) AS nbrOfMovies RETURN actor{.name, nbrOfMovies}
MATCH (actor:`Person` {name: 'Charlie Sheen'}) RETURN actor{.*, .age}
MATCH (p {name: 'Peter'}) SET p = {name: 'Peter Smith', position: 'Entrepreneur'} RETURN p.name, p.age, p.position
MATCH (p {name: 'Peter'}) SET p += {age: 38, hungry: true, position: 'Entrepreneur'} RETURN p.name, p.age, p.hungry, p.position
MATCH (p {name: 'Peter'}) SET p += {} RETURN p.name, p.age
MATCH (n {name: 'Andy'}) SET n.position = 'Developer', n.surname = 'Taylor'
MATCH (n {name: 'Andy'}) SET n.surname = $surname RETURN n.name, n.surname
MATCH (n {name: 'Stefan'}) SET n:`German` RETURN n.name, labels(n) AS labels
MATCH (n {name: 'George'}) SET n:`Swedish`:`Bossman` RETURN n.name, labels(n) AS labels
MATCH (a {name: 'Andy'}) REMOVE a.age RETURN a.name, a.age
MATCH (n {name: 'Peter'}) REMOVE n:`German` RETURN n.name, labels(n)
MATCH (n {name: 'Peter'}) REMOVE n:`German`:`Swedish` RETURN n.name, labels(n)
MATCH (n:`Actor`) RETURN n.name AS name UNION ALL MATCH (n:`Movie`) RETURN n.title AS name
MATCH (n:`Actor`) RETURN n.name AS name UNION MATCH (n:`Movie`) RETURN n.title AS name
UNWIND [1, 2, 3, NULL] AS x RETURN x, 'val' AS y
WITH [1, 1, 2, 2] AS coll UNWIND coll AS x WITH DISTINCT x RETURN collect(x) AS setOfVals
WITH [1, 2] AS a, [3, 4] AS b UNWIND (a + b) AS x RETURN x
WITH [[1, 2], [3, 4], 5] AS nested UNWIND nested AS x UNWIND x AS y RETURN y
UNWIND [] AS empty RETURN empty, 'literal_that_is_not_returned'
MATCH p = (start)-[*]->(finish) WHERE (start.name = 'A' AND finish.name = 'D') RETURN p
MATCH (person:`Person`) WHERE person.firstname STARTS WITH 'And' RETURN person
----

=== Hints

You can also use hints:

[[statements-input-hints]]
.Output
[source,cypher,separated=true]
----
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411}) RETURN *;
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411})
USING INDEX p:Pioneer(born)
RETURN *;
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411})
USING INDEX i:INVENTED_BY(year)
RETURN *;
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411})
USING INDEX s:Scientist(born)
USING INDEX cc:Country(formed)
RETURN *;
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411})
USING SCAN s:Scientist
RETURN *;
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411})
USING SCAN i:INVENTED_BY
RETURN *;
MATCH (s:Scientist {born: 1850})-[:RESEARCHED]->(sc:Science)<-[i:INVENTED_BY {year: 560}]-(p:Pioneer {born: 525})-[:LIVES_IN]->(c:City)-[:PART_OF]->(cc:Country {formed: 411})
USING INDEX s:Scientist(born)
USING INDEX cc:Country(formed)
USING JOIN ON p
RETURN *;
MATCH (s:Scientist {born: 1850})
OPTIONAL MATCH (s)-[:RESEARCHED]->(sc:Science)
USING JOIN ON s
RETURN *;
----

[[statements-output-hints]]
.Output
[source,cypher]
----
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) RETURN *
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) USING INDEX p:`Pioneer`(born) RETURN *
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) USING INDEX i:`INVENTED_BY`(year) RETURN *
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) USING INDEX s:`Scientist`(born) USING INDEX cc:`Country`(formed) RETURN *
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) USING SCAN s:`Scientist` RETURN *
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) USING SCAN i:`INVENTED_BY` RETURN *
MATCH (s:`Scientist` {born: 1850})-[:`RESEARCHED`]->(sc:`Science`)<-[i:`INVENTED_BY` {year: 560}]-(p:`Pioneer` {born: 525})-[:`LIVES_IN`]->(c:`City`)-[:`PART_OF`]->(cc:`Country` {formed: 411}) USING INDEX s:`Scientist`(born) USING INDEX cc:`Country`(formed) USING JOIN ON p RETURN *
MATCH (s:`Scientist` {born: 1850}) OPTIONAL MATCH (s)-[:`RESEARCHED`]->(sc:`Science`) USING JOIN ON s RETURN *
----

Of course, `USING PERIODIC` is supported, too:

[[statements-input-hints-periodic]]
.Output
[source,cypher,alwaysEscape=false,separated=true]
----
USING PERIODIC COMMIT LOAD CSV FROM 'file:///artists.csv' AS line
CREATE (:Artist {name: line[1], year: toInteger(line[2])});
USING PERIODIC COMMIT 500 LOAD CSV FROM 'file:///artists.csv' AS line
CREATE (:Artist {name: line[1], year: toInteger(line[2])});
LOAD CSV FROM 'file:///artists-with-escaped-char.csv' AS line
CREATE (a:Artist {name: line[1], year: toInteger(line[2])})
RETURN
  a.name AS name,
  a.year AS year,
  size(a.name) AS size;
LOAD CSV FROM 'file:///artists.csv' AS line
RETURN linenumber() AS number, line;
LOAD CSV FROM 'file:///artists.csv' AS line
RETURN DISTINCT file() AS path;
----

[[statements-output-hints-periodic]]
.Output
[source,cypher,alwaysEscape=false]
----
USING PERIODIC COMMIT LOAD CSV FROM 'file:///artists.csv' AS line CREATE (:Artist {name: line[1], year: toInteger(line[2])})
USING PERIODIC COMMIT 500 LOAD CSV FROM 'file:///artists.csv' AS line CREATE (:Artist {name: line[1], year: toInteger(line[2])})
LOAD CSV FROM 'file:///artists-with-escaped-char.csv' AS line CREATE (a:Artist {name: line[1], year: toInteger(line[2])}) RETURN a.name AS name, a.year AS year, size(a.name) AS size
LOAD CSV FROM 'file:///artists.csv' AS line RETURN linenumber() AS number, line
LOAD CSV FROM 'file:///artists.csv' AS line RETURN DISTINCT file() AS path
----

== Expressions

You can parse expressions, too.
They can be used to enrich queries in many places, for example as conditions or properties.

=== Usable datatypes

[[expressions-input-datatypes]]
.Input
[source,cypher]
----
1
-1
0XF
0xF
-0xE
010
-010
1.1
3.14
6.022E23
6.022e+24.0
TRUE
true
True
fAlse
FALSE
----

[[expressions-output-datatypes]]
.Output
[source,cypher]
----
1
-1
15
15
-14
8
-8
1.1
3.14
6.022E23
6.022E24
true
true
true
false
false
----

=== Operators and conditions

[[expressions-input-0]]
.Input
[source,cypher]
----
+1
+-1
-1
--1
NOT true
2+2
2-2
2*2
2/2
2%2
2^2
n.f <> 1
n.f != 1
n.f = 1
n.f <= 1
n.f >= 1
n.f < 1
n.f > 1
n.f =~ '.*'
n.f ends with "foo"
n.f starts with 'foo'
n.f contains 'foo'
n.f is NULL
actor{.name, .realName, movies: collect(movie{.title, .year})}
----

[[expressions-output-0]]
.Rendered output
[source,cypher]
----
+1
+-1
-1
--1
NOT (true)
(2 + 2)
(2 - 2)
(2 * 2)
(2 / 2)
(2 % 2)
2^2
n.f <> 1
n.f <> 1
n.f = 1
n.f <= 1
n.f >= 1
n.f < 1
n.f > 1
n.f =~ '.*'
n.f ENDS WITH 'foo'
n.f STARTS WITH 'foo'
n.f CONTAINS 'foo'
n.f IS NULL
actor{.name, .realName, movies: collect(movie{.title, .year})}
----

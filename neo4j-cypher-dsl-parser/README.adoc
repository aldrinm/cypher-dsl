= TCK for Cypher-DSL Parser

== Nodes

Nodes can be parsed and used in constructions of queries for example.
They are probably one of the most useful elements.

Parse them via:

[source,java,indent=0,tabsize=4]
----
import org.neo4j.cypherdsl.parser.CypherParser;

public class Demo {
	public static void main(String...a) {
		var node = CypherParser.parseNode("(m:Movie)");
	}
}
----

[[nodes-input]]
.Input
[source,cypher]
----
()
(:`A`)
(:A)
(:A:B)
(:A:`B`:C)
(m)
(m:Movie)
(m {a:'b'})
(m {a:'b', c: 'd'})
----

They will look like this when rendered with the default renderer:

[[nodes-output]]
.Output
[source,cypher]
----
()
(:`A`)
(:`A`)
(:`A`:`B`)
(:`A`:`B`:`C`)
(m)
(m:`Movie`)
(m {a: 'b'})
(m {a: 'b', c: 'd'})
----

== Clauses

Clauses can be parsed like this:

[source,java,indent=0,tabsize=4]
----
import java.util.List;

import org.neo4j.cypherdsl.core.Statement;
import org.neo4j.cypherdsl.core.renderer.Renderer;

public class Demo {
	public static void main(String... a) {
		var clause = CypherParser.parseClause("MATCH (tom:Person {name: \"Tom Hanks\"})-[:ACTED_IN]->(tomHanksMovies)");
		var cypher = Renderer.getDefaultRenderer().render(Statement.of(List.of(clause)));
		System.out.println(cypher);
	}
}
----

These are the supported clauses:

[[clauses-input]]
.Input
[source,cypher]
----
MATCH (tom {name: "Tom Hanks"})
MATCH (tom:Person {name: "Tom Hanks"})-[:ACTED_IN]->(tomHanksMovies)
MATCH (n:Movie), (m:Person)
DELETE n
DETACH DELETE n
RETURN n
RETURN n ORDER by n.name
RETURN n ORDER by n.name desc
RETURN n ORDER by n.name SKIP 5
RETURN n ORDER by n.name SKIP 5 LIMIT 10
RETURN n ORDER by n.name, n.firstName SKIP 5 LIMIT 10
RETURN n.name AS name, n.firstName as vorname ORDER by n.name, n.firstName SKIP 5 LIMIT 10
RETURN distinct n
RETURN collect(n)
CREATE (m:Movie)
CREATE (m:Movie {title: "A title"})
CREATE (a:Person) -[:ACTED_IN] -> (m:Movie {title: "A title"})
MERGE (m:Movie)
MERGE (m:Movie {title: "A title"})
MERGE (a:Person) -[:ACTED_IN] -> (m:Movie {title: "A title"})
WITH a
WITH a WHERE a.name = 'Michael'
WITH a ORDER by n.name, n.firstName desc SKIP 5 LIMIT 10 WHERE a.name = 'Michael'
----

[[clauses-output]]
.Rendered output
[source,cypher]
----
MATCH (tom {name: 'Tom Hanks'})
MATCH (tom:`Person` {name: 'Tom Hanks'})-[:`ACTED_IN`]->(tomHanksMovies)
MATCH (n:`Movie`), (m:`Person`)
DELETE n
DETACH DELETE n
RETURN n
RETURN n ORDER BY n.name ASC
RETURN n ORDER BY n.name DESC
RETURN n ORDER BY n.name ASC SKIP 5
RETURN n ORDER BY n.name ASC SKIP 5 LIMIT 10
RETURN n ORDER BY n.name ASC, n.firstName ASC SKIP 5 LIMIT 10
RETURN n.name AS name, n.firstName AS vorname ORDER BY n.name ASC, n.firstName ASC SKIP 5 LIMIT 10
RETURN DISTINCT n
RETURN collect(n)
CREATE (m:`Movie`)
CREATE (m:`Movie` {title: 'A title'})
CREATE (a:`Person`)-[:`ACTED_IN`]->(m:`Movie` {title: 'A title'})
MERGE (m:`Movie`)
MERGE (m:`Movie` {title: 'A title'})
MERGE (a:`Person`)-[:`ACTED_IN`]->(m:`Movie` {title: 'A title'})
WITH a
WITH a WHERE a.name = 'Michael'
WITH a ORDER BY n.name ASC, n.firstName DESC SKIP 5 LIMIT 10 WHERE a.name = 'Michael'
----

== Whole queries

Of course, you can parse a query into a Cypher-DSL statement.
Such a statement could be combined with another statement into `UNION` query or be used as a subquery.

[[statements-input]]
.Input
[source,cypher,separated=true]
----
MATCH (a {name: 'Andy'})
REMOVE a.age
RETURN a.name, a.age;
MATCH (n {name: 'Peter'})
REMOVE n:German
RETURN n.name, labels(n);
MATCH (n {name: 'Peter'})
REMOVE n:German:Swedish
RETURN n.name, labels(n);
MATCH (n {name: 'Andy'})
SET n.surname = 'Taylor'
RETURN n.name, n.surname;
MATCH (n {name: 'Andy'})
SET (CASE WHEN n.age = 36 THEN n END).worksIn = 'Malmo'
RETURN n.name, n.worksIn;
MATCH
  (at {name: 'Andy'}),
  (pn {name: 'Peter'})
SET at = pn
RETURN at.name, at.age, at.hungry, pn.name, pn.age;
----

[[statements-output]]
.Output
[source,cypher]
----
MATCH (a {name: 'Andy'}) REMOVE a.age RETURN a.name, a.age
MATCH (n {name: 'Peter'}) REMOVE n:`German` RETURN n.name, labels(n)
MATCH (n {name: 'Peter'}) REMOVE n:`German`:`Swedish` RETURN n.name, labels(n)
MATCH (n {name: 'Andy'}) SET n.surname = 'Taylor' RETURN n.name, n.surname
MATCH (n {name: 'Andy'}) SET (CASE WHEN n.age = 36 THEN n END).worksIn = 'Malmo' RETURN n.name, n.worksIn
MATCH (at {name: 'Andy'}), (pn {name: 'Peter'}) SET at = pn RETURN at.name, at.age, at.hungry, pn.name, pn.age
----

== Expressions

You can parse expressions, too.
They can be used to enrich queries in many places, for example as conditions or properties.

=== Usable datatypes

[[expressions-input-datatypes]]
.Input
[source,cypher]
----
1
-1
0XF
0xF
-0xE
010
-010
1.1
3.14
6.022E23
6.022e+24.0
TRUE
true
True
fAlse
FALSE
----

[[expressions-output-datatypes]]
.Output
[source,cypher]
----
1
-1
15
15
-14
8
-8
1.1
3.14
6.022E23
6.022E24
true
true
true
false
false
----

=== Operators and conditions

[[expressions-input-0]]
.Input
[source,cypher]
----
+1
+-1
-1
--1
NOT true
2+2
2-2
2*2
2/2
2%2
2^2
n.f <> 1
n.f != 1
n.f = 1
n.f <= 1
n.f >= 1
n.f < 1
n.f > 1
n.f =~ '.*'
n.f ends with "foo"
n.f starts with 'foo'
n.f contains 'foo'
n.f is NULL
----

[[expressions-output-0]]
.Rendered output
[source,cypher]
----
+1
+-1
-1
--1
NOT (true)
(2 + 2)
(2 - 2)
(2 * 2)
(2 / 2)
(2 % 2)
2^2
n.f <> 1
n.f <> 1
n.f = 1
n.f <= 1
n.f >= 1
n.f < 1
n.f > 1
n.f =~ '.*'
n.f ENDS WITH 'foo'
n.f STARTS WITH 'foo'
n.f CONTAINS 'foo'
n.f IS NULL
----
